name: Orchestrator

on:
  schedule:
    - cron: '0 6 * * *' # Tous les jours Ã  6h
  workflow_dispatch:
      inputs:
        force_version:
          description: 'Force le dÃ©ploiement de cette version (ex: 2025.11.0). Si vide, vÃ©rifie Bitwarden.'
          required: false
          type: string
          
permissions:
  contents: write
  packages: write
  pull-requests: write
  id-token: write

jobs:
  # Ã‰TAPE 1 : DÃ‰TECTION
check:
    runs-on: ubuntu-latest
    outputs:
      update_needed: ${{ steps.check.outputs.update_needed }}
      # ðŸš¨ DÃ©finition de la version : forcÃ©e ou dÃ©tectÃ©e
      version: ${{ steps.set_version.outputs.version }} 
    steps:
      - name: Checkout
        uses: actions/checkout@v6 

      - name: DÃ©terminer la Version Ã  utiliser
        id: set_version
        run: |
          # Si force_version est donnÃ©e, on utilise cette valeur
          if [ "${{ github.event.inputs.force_version }}" != "" ]; then
            FORCED_VERSION="${{ github.event.inputs.force_version }}"
            echo "version=$FORCED_VERSION" >> $GITHUB_OUTPUT
            echo "update_needed=true" >> $GITHUB_OUTPUT
            echo "âš ï¸ DÃ©ploiement ForcÃ© de la version $FORCED_VERSION."
            exit 0 # ArrÃªte la vÃ©rification Bitwarden

          # Sinon, on vÃ©rifie l'amont (logique inchangÃ©e)
          LATEST=$(curl -s https://api.github.com/repos/bitwarden/clients/releases | jq -r '[.[] | select(.tag_name | startswith("cli-v")) | .tag_name] | first' | sed 's/^cli-v//')
          CURRENT=$(cat VERSION 2>/dev/null || echo "0.0.0")
          
          if [ "$LATEST" != "$CURRENT" ]; then
            echo "update_needed=true" >> $GITHUB_OUTPUT
            echo "version=$LATEST" >> $GITHUB_OUTPUT
            echo "ðŸš€ Nouvelle version dÃ©tectÃ©e : $LATEST"
          else
            echo "update_needed=false" >> $GITHUB_OUTPUT
            echo "âœ… Ã€ jour."
          fi

  # Ã‰TAPE 2 : TEST SUR BRANCHE VIRTUELLE (Appel CI-CD en mode Dry Run)
  test-dev:
    needs: check
    if: needs.check.outputs.update_needed == 'true'
    # ðŸ‘‡ C'est ici qu'il appelle l'autre fichier
    uses: ./.github/workflows/ci-cd.yaml
    with:
      version: ${{ needs.check.outputs.version }}
      dry_run: true # TRUE = On teste seulement (build docker dev)
    secrets: inherit

  # Ã‰TAPE 3 : MERGE (Si le test a rÃ©ussi)
  merge:
    needs: [check, test-dev]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Commit & Merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.check.outputs.version }}"
          BRANCH="auto-$VERSION"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # On prÃ©pare le terrain
          git checkout -b "$BRANCH"
          echo "$VERSION" > VERSION
          git add VERSION
          git commit -m "chore: update to $VERSION"
          git push origin "$BRANCH" --force
          
          # On crÃ©e la PR et on la valide DANS LA FOULÃ‰E
          # (On a le droit car on a testÃ© juste avant Ã  l'Ã©tape 2)
          PR=$(gh pr create --title "Bump $VERSION" --body "Auto-validated." --base master --head "$BRANCH")
          gh pr merge "$PR" --merge --delete-branch

  # Ã‰TAPE 4 : RELEASE PROD (Appel CI-CD en mode Prod)
  release-prod:
    needs: [check, merge]
    uses: ./.github/workflows/ci-cd.yaml
    with:
      version: ${{ needs.check.outputs.version }}
      dry_run: false # FALSE = C'est la prod (build latest + release github)
    secrets: inherit